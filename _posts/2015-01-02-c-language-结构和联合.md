---

layout: post
title:  C语言---结构和联合
category: c

---


#结构和联合

***

##1. 结构基础知识

聚合数据类型能够同时存储超过一个的单独数据。 C提供了两种类型的聚合数据类型，数组和结构。 数组是相同类型的元素的集合，它的每个元素是通过下标引用或指针间接访问来选择的。

结构也是一些值的集合，这些值称为它的成员，但是一个结构的各个成员可以具有不同的类型。

数组元素可以通过下标访问，这是因为数组元素的长度相同。但是，在结构中情况并非如此。由于一个结构的成员可能长度不同，所以不能使用下标来访问它们。相反，每个结构成员都有自己的名字，它们是通过名字访问的。

这个区别非常重要。结构并不是一个它自身成员的数组。和数组名不用，当一个结构变量在表达式中使用时，它并不被替换成一个指针。结构变量也无法使用下标来选择特定的成员。

结构变量属于标量类型，所以你可以像对待其他标量类型那样执行相同类型的操作。结构也可以作为传递给函数的参数，它们也可以作为返回值从函数返回，相同类型的结构变量之间可以赋值。你可以声明指向结构的指针，取一个结构变量的地址，也可以声明结构数组。


###1.1 结构声明

在声明结构时，必须列出它包含的所有成员。这个列表包括每个的成员的类型和名字。

		struct tag { member-list } variable-list ;

结构声明的语法需要作一些解释。所有可选部分不能全部省略----它们至少出现两个。

以下例子：

		struct {
			int a;
			char b;
			float c;
		} x;

		这个声明创建了一个名叫x得变量，它包含三个成员：一个整数、一个字符和一个浮点数。


		struct {
			int a;
			char b;
			float c;
		} y[20], *z;

		这个声明创建了y和z。y是一个数组，它包含了20个结构。z是一个指针，它指向这个类型的结构。

**警告:**

这个两个声明被编译器当作两种截然不同的类型，即使它们的成员列表完全相同。因此，变量y和z的类型与x的类型不同，所以下面这条语句:

z = &x; 是非法的。


但是，这是不是意味着某种特定类型的所有结构都必须使用一个单独的声明来创建呢？幸运地是，事实并非如此。标签（tag）字段允许为成员列表提供一个名字，这样它就可以在后续的声明中使用。标签允许多个声明使用同一个成员列表，并且创建同一个类型的结构。这里有个例子

		struct SIMPLE {
			int a;
			char b;
			float c;
		};

这个声明把标签SIMPLE和这个成员列表联系在一起。该声明并没有提供变量列表，所以它并未创建任何变量。这个声明类似于制造一个甜饼切割器。甜饼切割器决定制造出来的甜饼的形状，但甜饼切割器本身却不是甜饼。标签标识了一种模式，用于声明未来的变量，但无论是标签还是模式本身都不是变量。

	struct SIMPLE x;
	struct SIMPLE y[20], *z;

这些声明使用标签来创建变量。它们创建和最初两个例子一样的变量，但存在一个重要的区别----现在x、y和z都是同一种类型的结构变量。

声明结构时可以使用另一种良好的技巧使用typedef创建一种新的类型，如下面的例子所示。

		typedef struct {
			int a;
			char b;
			float c;
		} SIMPLE;

这个技巧和声明一个结构标签效果几乎相同。区别在于SIMPLP现在是个类型名而不是个结构标签，所以后续声明可能像下面这个样子：

		SIMPLE x；
		SIMPLE y[2], *z；


**提示**

如果想再多个源文件中使用同一种类型的结构，应该把标签声明或typedef形式的声明放在一个头文件中。当源文件需要这个声明时可以使用#include指令把那个头文件包含进来。

###1.2 结构成员

在一个结构外部声明的任何变量都可以作为结构的成员。尤其是，结构成员可以是标量、数组、指针甚至是其他结构。
下面是一个更为复杂的例子：

		struct COMPLEX {
			float f;
			int a[20];
			long *lp;
			struct SIMPLE s;
			struct SIMPLE sa[10];
			struct SIMPLE *sp;
		};

一个结构成员的名字可以喝其他结构的成员的名字相同。

###1.3 结构成员的直接访问

结构变量的成员是通过点操作符（.)访问的。点操作符接受两个操作数，左操作数就是结构变量的名字，右操作数就是需要访问的成员的名字。这个表达式的结果就是指定的成员。例如，考虑下面这个声明：

		struct COMPLEX comp；

名字为a的成员是一个数组，所以表达式comp.a就选择了这个成员。这个表达式的结果是个数组名，所以你可以把它用在任何可以使用数组名的地方。类似地，成员s是个结构，所以表达式comp.s的结果是个结构名，它可以用于任何可以使用普通结构变量的地方。尤其是，我们可以把这个表达式用作另一个点操作符的左操作数。


###1.3 结构成员的间接访问

如果拥有一个指向结构的指针，该如何访问这个结构的成员呢？首先就是对指针执行间接访问操作，来获得这个结构，然后使用点操作符来访问它的成员。但是，点操作符的优先级高于间接访问操作符，所以必须在表达式中使用括号，确保间接访问首先执行。举个例子，假定一个函数的参数是个指向结构的指针，如下原型所示：

		void func( stuct COMPLEX *cp ) ;

		函数可以使用下面的这个表达式来访问这个变量所指向的结构成员f：

		（*cp).f

		对指针执行间接访问将访问结构，然后点操作符访问一个成员。

由于这个概念有点麻烦，所以C语言提供了一个更为方便的操作符来完成这项工作-----（->）操作符就是箭头操作符。和点操作符一样，箭头操作符接受连个操作数，但左操作数必须是一个指向结构的**指针**。箭头操作符对左操作数执行间接访问取得指针所指向的结构，然后和点操作符一样，根据右操作数选择一个指定的结构成员。但是，间接访问操作内建于箭头操作符中，所以我们不需要显式地执行间接访问或者使用括号。这里有一些例子，像前面一样使用同一个指针。

		cp->f
		cp->a
		cp->s
第一个表达式访问结构的浮点数成员，第2个表达式访问一个数组名，第3个表达式则访问一个结构。


###1.4 结构的自引用

在一个结构内部包含一个类型为该结构本身的成员是否合法呢？看如下例子，可以说明这个想法。

		struct SELF_REF1 {
				int a;
				struct SELF_REF1 b;
				int c;
		}

		这种类型的自引用是非法的，因为成员b是另一个完整地结构，其内部还将包含它自己的成员b。这第二个成员又是另一个完整地机构，它还将包括自己的成员b。这样重复下去永无止境。这有点像不会终止的递归程序。但下面这个声明却是合法的。

		
		struct SELF_REF2 {
				int a;
				struct SELF_REF2 *b;
				int c;
		}

		这个声明和前面那个声明的区别在于b现在是一个指针而不是结构。编译器在结构的长度确定之前就已经知道指针的长度，所以这种类型的自引用是合法的。如果觉得一个结构内部包含一个指向该结构的指针有些奇怪，请记住它事实上所指向的是同一种类型的不同结构。
		
		更加高级的数据结构，如链表和树，都是这种技巧实现的。每个结构指向链表的下一个元素或树的下一个分支。

**警告**
警惕下面这个陷阱：
		typedef struct {
			int a;
			SELF_REF3 *b;
			int c;
		} SELF_REF3;

		这个声明的目的是为这个结构创建类型名SELF_REF3。但是，它失败了。类型名直到声明的末尾才定义，所以在结构声明的内部它尚未定义。

		解决方案是定义一个结构标签来声明，如下所示：

		typedef struct SELF_REF3_TAG{
			int a;
			struct SELF_REF3_TAG *b;
			int c;
		} SELF_REF3;

###1.4 结构的自引用

在一个结构内部包含一个类型为该结构本身的成员是否合法呢？看如下例子，可以说明这个想法。

		struct SELF_REF1 {
				int a;
				struct SELF_REF1 b;
				int c;
		}

		这种类型的自引用是非法的，因为成员b是另一个完整地结构，其内部还将包含它自己的成员b。这第二个成员又是另一个完整地机构，它还将包括自己的成员b。这样重复下去永无止境。这有点像不会终止的递归程序。但下面这个声明却是合法的。

		
		struct SELF_REF2 {
				int a;
				struct SELF_REF2 *b;
				int c;
		}

		这个声明和前面那个声明的区别在于b现在是一个指针而不是结构。编译器在结构的长度确定之前就已经知道指针的长度，所以这种类型的自引用是合法的。如果觉得一个结构内部包含一个指向该结构的指针有些奇怪，请记住它事实上所指向的是同一种类型的不同结构。
		
		更加高级的数据结构，如链表和树，都是这种技巧实现的。每个结构指向链表的下一个元素或树的下一个分支。

**警告**
警惕下面这个陷阱：
		typedef struct {
			int a;
			SELF_REF3 *b;
			int c;
		} SELF_REF3;

		这个声明的目的是为这个结构创建类型名SELF_REF3。但是，它失败了。类型名直到声明的末尾才定义，所以在结构声明的内部它尚未定义。

		解决方案是定义一个结构标签来声明，如下所示：

		typedef struct SELF_REF3_TAG{
			int a;
			struct SELF_REF3_TAG *b;
			int c;
		} SELF_REF3;


###1.5 不完整的声明

偶尔，你必须声明一些相互之间存在依赖的结构。也就是说，其中一个结构包含了另一个结构的一个或多个成员。和自引用结构一样，至少有一个结构必须在另一个结构内部以指针的形式存在。问题在于声明部分：如果每个结构都引用了其他结构的标签，哪个结构应该首先声明呢？

这个问题的解决方案是使用不完整声明，它声明一个作为结构标签的标示符。然后，我们可以把这个标签用在不需要知道这个结构的长度的声明中，如声明指向这个结构的指针。接下来的声明把这个标签与成员列表联系在一起。





